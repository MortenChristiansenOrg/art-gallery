import { v } from "convex/values";
import { query, mutation, internalMutation } from "./_generated/server";
import { internal } from "./_generated/api";
import { requireAuth } from "./auth";

// Build DZI URL from artwork ID
function getDziUrl(artworkId: string, dziStatus?: string): string | null {
  if (dziStatus !== "complete") return null;
  // Use relative URL - will be resolved by the HTTP router
  return `/dzi/${artworkId}.dzi`;
}

export const list = query({
  args: {
    collectionId: v.optional(v.id("collections")),
    publishedOnly: v.optional(v.boolean()),
  },
  handler: async (ctx, args) => {
    let artworks;
    if (args.collectionId) {
      artworks = await ctx.db
        .query("artworks")
        .withIndex("by_collection", (q) => q.eq("collectionId", args.collectionId))
        .collect();
    } else {
      artworks = await ctx.db.query("artworks").collect();
    }

    if (args.publishedOnly) {
      // Only show published artworks with processed images AND complete DZI
      artworks = artworks.filter(
        (a) => a.published && a.thumbnailId && a.dziStatus === "complete"
      );
    }

    artworks.sort((a, b) => a.order - b.order);

    return Promise.all(
      artworks.map(async (artwork) => ({
        ...artwork,
        imageUrl: await ctx.storage.getUrl(artwork.imageId),
        thumbnailUrl: artwork.thumbnailId
          ? await ctx.storage.getUrl(artwork.thumbnailId)
          : null,
        viewerImageUrl: artwork.viewerImageId
          ? await ctx.storage.getUrl(artwork.viewerImageId)
          : null,
        dziUrl: getDziUrl(artwork._id, artwork.dziStatus),
      }))
    );
  },
});

export const get = query({
  args: {
    id: v.id("artworks"),
    publishedOnly: v.optional(v.boolean()),
  },
  handler: async (ctx, args) => {
    const artwork = await ctx.db.get(args.id);
    if (!artwork) return null;

    // For public access, require published + processed images + complete DZI
    if (
      args.publishedOnly &&
      (!artwork.published || !artwork.thumbnailId || artwork.dziStatus !== "complete")
    ) {
      return null;
    }

    return {
      ...artwork,
      imageUrl: await ctx.storage.getUrl(artwork.imageId),
      thumbnailUrl: artwork.thumbnailId
        ? await ctx.storage.getUrl(artwork.thumbnailId)
        : null,
      viewerImageUrl: artwork.viewerImageId
        ? await ctx.storage.getUrl(artwork.viewerImageId)
        : null,
      dziUrl: getDziUrl(artwork._id, artwork.dziStatus),
    };
  },
});

export const create = mutation({
  args: {
    token: v.string(),
    title: v.string(),
    description: v.optional(v.string()),
    imageId: v.id("_storage"),
    collectionId: v.optional(v.id("collections")),
    year: v.optional(v.number()),
    medium: v.optional(v.string()),
    dimensions: v.optional(v.string()),
    published: v.boolean(),
  },
  handler: async (ctx, args) => {
    requireAuth(args.token);
    const { token: _, ...data } = args;
    const existing = await ctx.db.query("artworks").collect();
    const maxOrder = existing.reduce((max, a) => Math.max(max, a.order), -1);

    return ctx.db.insert("artworks", {
      ...data,
      order: maxOrder + 1,
      createdAt: Date.now(),
    });
  },
});

export const update = mutation({
  args: {
    token: v.string(),
    id: v.id("artworks"),
    title: v.optional(v.string()),
    description: v.optional(v.string()),
    imageId: v.optional(v.id("_storage")),
    collectionId: v.optional(v.id("collections")),
    year: v.optional(v.number()),
    medium: v.optional(v.string()),
    dimensions: v.optional(v.string()),
    published: v.optional(v.boolean()),
    order: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    requireAuth(args.token);
    const { id, token: _, ...updates } = args;

    // If imageId is being updated, cleanup old tiles and reset DZI status
    if (updates.imageId) {
      const artwork = await ctx.db.get(id);
      if (artwork && artwork.imageId !== updates.imageId) {
        // Delete old image variants
        if (artwork.thumbnailId) await ctx.storage.delete(artwork.thumbnailId);
        if (artwork.viewerImageId) await ctx.storage.delete(artwork.viewerImageId);
        // Schedule old tile cleanup
        await ctx.scheduler.runAfter(0, internal.dzi.cleanupTiles, {
          artworkId: id,
        });
        // Reset DZI status (new tiles will be generated by images.ts)
        await ctx.db.patch(id, {
          dziStatus: "pending",
          dziMetadata: undefined,
          thumbnailId: undefined,
          viewerImageId: undefined,
        });
      }
    }

    const filtered = Object.fromEntries(
      Object.entries(updates).filter(([, v]) => v !== undefined)
    );
    await ctx.db.patch(id, filtered);
  },
});

export const remove = mutation({
  args: { token: v.string(), id: v.id("artworks") },
  handler: async (ctx, args) => {
    requireAuth(args.token);
    const artwork = await ctx.db.get(args.id);
    if (artwork) {
      await ctx.storage.delete(artwork.imageId);
      if (artwork.thumbnailId) await ctx.storage.delete(artwork.thumbnailId);
      if (artwork.viewerImageId) await ctx.storage.delete(artwork.viewerImageId);
      // Schedule tile cleanup (async, don't block deletion)
      await ctx.scheduler.runAfter(0, internal.dzi.cleanupTiles, {
        artworkId: args.id,
      });
      await ctx.db.delete(args.id);
    }
  },
});

export const reorder = mutation({
  args: {
    token: v.string(),
    ids: v.array(v.id("artworks")),
  },
  handler: async (ctx, args) => {
    requireAuth(args.token);
    for (let i = 0; i < args.ids.length; i++) {
      await ctx.db.patch(args.ids[i], { order: i });
    }
  },
});

export const updateVariants = internalMutation({
  args: {
    artworkId: v.id("artworks"),
    thumbnailId: v.id("_storage"),
    viewerImageId: v.id("_storage"),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.artworkId, {
      thumbnailId: args.thumbnailId,
      viewerImageId: args.viewerImageId,
    });
  },
});
